use axum::{
    body::Body,
    http::{Request, StatusCode},
};
use serde_json::{json, Value};
use tower::ServiceExt;
use tokio;

use railway_backend::{AppState, models::*, services::*, database::Database, auth::*, config::AppConfig, metrics::AppMetrics};
use std::sync::Arc;

/// Setup test application state
async fn setup_test_app() -> AppState {
    let config = Arc::new(AppConfig::default());
    let metrics = Arc::new(AppMetrics::new().unwrap());
    
    // Use in-memory database for testing
    let db = Arc::new(Database::new().await.unwrap());
    
    let auth_service = Arc::new(AuthService::new(
        "test-secret-key-for-testing-at-least-32-chars",
        24,
    ));
    
    let train_service = Arc::new(TrainService::new(db.clone()));
    let optimization_service = Arc::new(OptimizationService::new());
    let ingestion_service = Arc::new(IngestionService::new(db.clone()));
    
    AppState {
        db,
        train_service,
        optimization_service,
        ingestion_service,
        auth_service,
        metrics,
        config,
    }
}

/// Create a test train
fn create_test_train() -> Train {
    Train::new(
        12345,
        "Test Express".to_string(),
        TrainPriority::Express,
        vec!["DEL".to_string(), "GGN".to_string(), "JPR".to_string()],
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_train_service_integration() {\n        let state = setup_test_app().await;\n        let train = create_test_train();\n        \n        // Test creating a train\n        let train_id = state.train_service.create_train(train.clone()).await.unwrap();\n        assert!(!train_id.is_empty());\n        \n        // Test retrieving the train\n        let retrieved_train = state.train_service.get_train(&train_id).await.unwrap();\n        assert_eq!(retrieved_train.train_number, 12345);\n        assert_eq!(retrieved_train.name, \"Test Express\");\n        \n        // Test updating train position\n        let new_position = GeoPoint { latitude: 28.7, longitude: 77.3 };\n        state.train_service.update_train_position(&train_id, new_position, 80.0).await.unwrap();\n        \n        let updated_train = state.train_service.get_train(&train_id).await.unwrap();\n        assert_eq!(updated_train.position.latitude, 28.7);\n        assert_eq!(updated_train.speed_kmh, 80.0);\n        \n        // Test adding delay\n        state.train_service.add_train_delay(&train_id, 15, Some(\"Signal failure\".to_string())).await.unwrap();\n        \n        let delayed_train = state.train_service.get_train(&train_id).await.unwrap();\n        assert_eq!(delayed_train.delay_minutes, 15);\n        assert_eq!(delayed_train.status, TrainStatus::Delayed);\n    }\n    \n    #[tokio::test]\n    async fn test_authentication_service() {\n        let auth_service = AuthService::new(\"test-secret-key-for-testing-at-least-32-chars\", 24);\n        \n        // Test valid credentials\n        let user = auth_service.authenticate_user(\"admin\", \"admin123\").await;\n        assert!(user.is_some());\n        \n        let user = user.unwrap();\n        assert_eq!(user.username, \"admin\");\n        assert_eq!(user.role, UserRole::Admin);\n        \n        // Test token generation and validation\n        let token = auth_service.generate_token(&user).unwrap();\n        let claims = auth_service.validate_token(&token).unwrap();\n        \n        assert_eq!(claims.username, \"admin\");\n        assert_eq!(claims.role, UserRole::Admin);\n        \n        // Test invalid credentials\n        let invalid_user = auth_service.authenticate_user(\"invalid\", \"wrong\").await;\n        assert!(invalid_user.is_none());\n    }\n    \n    #[tokio::test]\n    async fn test_optimization_service() {\n        let state = setup_test_app().await;\n        let trains = vec![create_test_train()];\n        \n        let optimization_request = crate::services::optimization_service::OptimizationRequest {\n            section_id: \"SEC001\".to_string(),\n            trains,\n            constraints: vec![],\n            objective: crate::services::optimization_service::OptimizationObjective::MinimizeDelay,\n            time_horizon_minutes: 120,\n        };\n        \n        let response = state.optimization_service.optimize_schedule(optimization_request).await.unwrap();\n        \n        assert!(response.success);\n        assert!(!response.optimized_schedule.is_empty());\n        assert!(response.computation_time_ms > 0);\n    }\n    \n    #[tokio::test]\n    async fn test_train_statistics_calculation() {\n        let state = setup_test_app().await;\n        \n        // Create multiple test trains with different delays\n        let mut trains = vec![];\n        for i in 0..5 {\n            let mut train = create_test_train();\n            train.train_number = 10000 + i;\n            train.delay_minutes = i as i32 * 5; // 0, 5, 10, 15, 20 minutes delay\n            \n            if train.delay_minutes > 0 {\n                train.status = TrainStatus::Delayed;\n            }\n            \n            let train_id = state.train_service.create_train(train).await.unwrap();\n            trains.push(train_id);\n        }\n        \n        // Calculate statistics\n        let stats = state.train_service.calculate_train_statistics().await.unwrap();\n        \n        assert_eq!(stats.total_active_trains, 5);\n        assert_eq!(stats.delayed_trains, 4); // 4 trains have delay > 0\n        assert_eq!(stats.on_time_trains, 1);  // 1 train has delay = 0\n        assert_eq!(stats.average_delay_minutes, 10.0); // Average of (0+5+10+15+20)/5\n    }\n    \n    #[tokio::test]\n    async fn test_role_based_authorization() {\n        let admin_role = RequireRole(UserRole::Admin);\n        let operator_role = RequireRole(UserRole::Operator);\n        let viewer_role = RequireRole(UserRole::Viewer);\n        \n        // Test admin permissions\n        assert!(admin_role.check_permission(&UserRole::Admin));\n        assert!(operator_role.check_permission(&UserRole::Admin));\n        assert!(viewer_role.check_permission(&UserRole::Admin));\n        \n        // Test operator permissions\n        assert!(!admin_role.check_permission(&UserRole::Operator));\n        assert!(operator_role.check_permission(&UserRole::Operator));\n        assert!(viewer_role.check_permission(&UserRole::Operator));\n        \n        // Test viewer permissions\n        assert!(!admin_role.check_permission(&UserRole::Viewer));\n        assert!(!operator_role.check_permission(&UserRole::Viewer));\n        assert!(viewer_role.check_permission(&UserRole::Viewer));\n    }\n    \n    #[tokio::test]\n    async fn test_synthetic_data_generation() {\n        use railway_backend::synthetic::train_generator::TrainGenerator;\n        use railway_backend::synthetic::disruption_generator::DisruptionGenerator;\n        \n        let train_generator = TrainGenerator::new();\n        let disruption_generator = DisruptionGenerator::new();\n        \n        // Create test sections\n        let sections = vec![\n            RailwaySection {\n                id: \"SEC001\".to_string(),\n                name: \"Test Section 1\".to_string(),\n                start_coordinates: GeoPoint { latitude: 28.6, longitude: 77.2 },\n                end_coordinates: GeoPoint { latitude: 28.7, longitude: 77.3 },\n                length_km: 50.0,\n                track_type: TrackType::Double,\n                max_speed_kmh: 110.0,\n                capacity_trains_per_hour: 20,\n                current_occupancy: 5,\n                status: SectionStatus::Active,\n                signals: vec![],\n                created_at: chrono::Utc::now(),\n                updated_at: chrono::Utc::now(),\n            },\n            RailwaySection {\n                id: \"SEC002\".to_string(),\n                name: \"Test Section 2\".to_string(),\n                start_coordinates: GeoPoint { latitude: 28.7, longitude: 77.3 },\n                end_coordinates: GeoPoint { latitude: 28.8, longitude: 77.4 },\n                length_km: 30.0,\n                track_type: TrackType::Single,\n                max_speed_kmh: 90.0,\n                capacity_trains_per_hour: 15,\n                current_occupancy: 3,\n                status: SectionStatus::Active,\n                signals: vec![],\n                created_at: chrono::Utc::now(),\n                updated_at: chrono::Utc::now(),\n            },\n        ];\n        \n        // Test train generation\n        let trains = train_generator.generate_trains_with_routes(10, &sections).await.unwrap();\n        assert_eq!(trains.len(), 10);\n        \n        for train in &trains {\n            assert!(!train.id.is_empty());\n            assert!(train.train_number >= 10000);\n            assert!(!train.name.is_empty());\n            assert!(!train.route.is_empty());\n        }\n        \n        // Test disruption generation\n        let disruptions = disruption_generator\n            .generate_disruptions(&trains, &sections, 0.3, 24)\n            .await\n            .unwrap();\n        \n        // Should generate some disruptions based on probability\n        assert!(!disruptions.is_empty());\n        \n        for disruption in &disruptions {\n            assert!(!disruption.id.is_empty());\n            assert!(!disruption.affected_sections.is_empty());\n            assert!(disruption.impact_level >= 1 && disruption.impact_level <= 10);\n        }\n    }\n    \n    #[tokio::test]\n    async fn test_config_management() {\n        let config = AppConfig::default();\n        \n        // Test validation\n        assert!(config.validate().is_ok());\n        \n        // Test config properties\n        assert_eq!(config.server.port, 8000);\n        assert_eq!(config.database.namespace, \"railway\");\n        assert!(config.security.jwt_secret.len() >= 32);\n        assert!(config.monitoring.prometheus_enabled);\n        \n        // Test server bind address generation\n        let bind_address = config.server_bind_address();\n        assert_eq!(bind_address, \"0.0.0.0:8000\");\n        \n        // Test database connection string\n        let db_conn = config.database_connection_string();\n        assert!(db_conn.contains(\"railway\"));\n        assert!(db_conn.contains(\"intelligence\"));\n    }\n    \n    #[tokio::test]\n    async fn test_metrics_collection() {\n        let metrics = AppMetrics::new().unwrap();\n        \n        // Test HTTP request recording\n        metrics.record_http_request();\n        metrics.record_http_duration(0.125);\n        \n        // Test optimization metrics\n        metrics.record_optimization_request(true, 2.5);\n        metrics.record_optimization_request(false, 1.2);\n        \n        // Test database metrics\n        metrics.record_database_query(0.05);\n        \n        // Test WebSocket metrics\n        metrics.update_websocket_connections(5);\n        metrics.record_websocket_message(true);\n        metrics.record_websocket_message(false);\n        \n        // Test system uptime\n        metrics.update_system_uptime(3600.0);\n        \n        // All metrics operations should complete without errors\n        assert!(true);\n    }\n}\n\n/// End-to-end test scenarios\n#[cfg(test)]\nmod e2e_tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_full_train_lifecycle() {\n        let state = setup_test_app().await;\n        \n        // 1. Create a train\n        let train = create_test_train();\n        let train_id = state.train_service.create_train(train.clone()).await.unwrap();\n        \n        // 2. Update train position multiple times (simulate movement)\n        let positions = vec![\n            GeoPoint { latitude: 28.6, longitude: 77.2 },\n            GeoPoint { latitude: 28.65, longitude: 77.25 },\n            GeoPoint { latitude: 28.7, longitude: 77.3 },\n        ];\n        \n        for (i, position) in positions.iter().enumerate() {\n            let speed = 60.0 + (i as f32 * 10.0);\n            state.train_service.update_train_position(&train_id, *position, speed).await.unwrap();\n        }\n        \n        // 3. Add some delay\n        state.train_service.add_train_delay(&train_id, 25, Some(\"Weather conditions\".to_string())).await.unwrap();\n        \n        // 4. Move train to different section\n        state.train_service.move_train_to_section(&train_id, \"SEC002\").await.unwrap();\n        \n        // 5. Verify final state\n        let final_train = state.train_service.get_train(&train_id).await.unwrap();\n        assert_eq!(final_train.delay_minutes, 25);\n        assert_eq!(final_train.current_section, \"SEC002\");\n        assert_eq!(final_train.status, TrainStatus::Delayed);\n    }\n    \n    #[tokio::test]\n    async fn test_optimization_workflow() {\n        let state = setup_test_app().await;\n        \n        // Create multiple trains for optimization\n        let mut trains = vec![];\n        for i in 0..5 {\n            let mut train = create_test_train();\n            train.train_number = 10000 + i;\n            train.delay_minutes = (i as i32) * 5;\n            \n            let train_id = state.train_service.create_train(train.clone()).await.unwrap();\n            train.id = train_id;\n            trains.push(train);\n        }\n        \n        // Create optimization request\n        let optimization_request = crate::services::optimization_service::OptimizationRequest {\n            section_id: \"SEC001\".to_string(),\n            trains,\n            constraints: vec![],\n            objective: crate::services::optimization_service::OptimizationObjective::MinimizeDelay,\n            time_horizon_minutes: 120,\n        };\n        \n        // Run optimization\n        let response = state.optimization_service.optimize_schedule(optimization_request).await.unwrap();\n        \n        assert!(response.success);\n        assert_eq!(response.optimized_schedule.len(), 5);\n        assert!(response.total_delay_reduction_minutes >= 0.0);\n    }\n    \n    #[tokio::test]\n    async fn test_disruption_handling() {\n        let state = setup_test_app().await;\n        \n        // Create a disruption event\n        let disruption = DisruptionEvent::new(\n            DisruptionType::SignalFailure,\n            vec![\"SEC001\".to_string()],\n            \"Signal failure at Junction XYZ\".to_string(),\n            7,\n        );\n        \n        // Store disruption in database\n        let disruption_id = state.db.create_disruption_event(&disruption).await.unwrap();\n        assert!(!disruption_id.is_empty());\n        \n        // Retrieve active disruptions\n        let active_disruptions = state.db.get_active_disruptions().await.unwrap();\n        assert!(!active_disruptions.is_empty());\n        \n        let found_disruption = active_disruptions.iter()\n            .find(|d| d.id == disruption_id)\n            .unwrap();\n        \n        assert_eq!(found_disruption.disruption_type, DisruptionType::SignalFailure);\n        assert_eq!(found_disruption.impact_level, 7);\n        assert!(found_disruption.is_active());\n    }\n    \n    #[tokio::test]\n    async fn test_system_performance_metrics() {\n        let state = setup_test_app().await;\n        \n        // Create trains with various states\n        let train_configs = vec![\n            (TrainStatus::Running, 0),\n            (TrainStatus::Running, 3),\n            (TrainStatus::Delayed, 15),\n            (TrainStatus::Delayed, 25),\n            (TrainStatus::AtStation, 0),\n        ];\n        \n        for (i, (status, delay)) in train_configs.iter().enumerate() {\n            let mut train = create_test_train();\n            train.train_number = 20000 + i as u32;\n            train.status = *status;\n            train.delay_minutes = *delay;\n            \n            state.train_service.create_train(train).await.unwrap();\n        }\n        \n        // Calculate statistics\n        let stats = state.train_service.calculate_train_statistics().await.unwrap();\n        \n        assert_eq!(stats.total_active_trains, 5);\n        assert_eq!(stats.delayed_trains, 2); // 2 trains with delay > 0\n        assert_eq!(stats.on_time_trains, 3);  // 3 trains with delay <= 0\n        \n        // Average delay should be (0+3+15+25+0)/5 = 8.6\n        assert!((stats.average_delay_minutes - 8.6).abs() < 0.1);\n    }\n    \n    #[tokio::test]\n    async fn test_concurrent_train_operations() {\n        let state = setup_test_app().await;\n        \n        // Create multiple trains concurrently\n        let mut handles = vec![];\n        \n        for i in 0..10 {\n            let state_clone = state.clone();\n            let handle = tokio::spawn(async move {\n                let mut train = create_test_train();\n                train.train_number = 30000 + i;\n                \n                state_clone.train_service.create_train(train).await\n            });\n            handles.push(handle);\n        }\n        \n        // Wait for all trains to be created\n        let mut train_ids = vec![];\n        for handle in handles {\n            let train_id = handle.await.unwrap().unwrap();\n            train_ids.push(train_id);\n        }\n        \n        assert_eq!(train_ids.len(), 10);\n        \n        // Update all trains concurrently\n        let mut update_handles = vec![];\n        \n        for (i, train_id) in train_ids.iter().enumerate() {\n            let state_clone = state.clone();\n            let train_id_clone = train_id.clone();\n            \n            let handle = tokio::spawn(async move {\n                let position = GeoPoint {\n                    latitude: 28.6 + (i as f64 * 0.01),\n                    longitude: 77.2 + (i as f64 * 0.01),\n                };\n                let speed = 50.0 + (i as f32 * 5.0);\n                \n                state_clone.train_service.update_train_position(&train_id_clone, position, speed).await\n            });\n            update_handles.push(handle);\n        }\n        \n        // Wait for all updates to complete\n        for handle in update_handles {\n            handle.await.unwrap().unwrap();\n        }\n        \n        // Verify all trains were updated\n        let final_trains = state.train_service.get_all_trains().await.unwrap();\n        assert!(final_trains.len() >= 10);\n    }\n}
